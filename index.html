<html>
	<head>
	<title>Hanging plotter simulator</title>
	<style>
	#wrapper {
	  margin-left: 350px;
	}
	#content {
	  float: left;
	  width: 100%;
	}
	#sidebar {
	  float: left;
	  width: 300px;
	  margin-left: -350px;
	}
	#cleared {
	  clear: both;
	}
	</style>	  
	</head>
	<body>
    <div id="wrapper">
        <div  id="content" style="position: relative;">
         <canvas id="canvas" width="650" height="600" 
           style="position: absolute; left: 0; top: 0; z-index: 0;"></canvas>
         <canvas id="drawinglayer" width="650" height="600" 
           style="position: absolute; left: 0; top: 0; z-index: 1;"></canvas>
        </div>   
		<div id="sidebar">GCode:</br></br>
			<textarea id="gcodes" rows="40" cols="40">
G17 G20 G90 G94 G54
G0 Z0.25
X-0.5 Y0.
Z0.1
G01 Z0. F5.
G02 X0. Y0.5 I0.5 J0. F2.5
X0.5 Y0. I0. J-0.5
X0. Y-0.5 I-0.5 J0.
X-0.5 Y0. I0. J0.5
G01 Z0.1 F5.
G00 X0. Y0. Z0.25
			</textarea>
			</br>
			<input type="button" value="Run" onClick="run();">
		</div>
		<div id="cleared"></div>
	</div>  
    </body>
    <script type="text/javascript" src="jquery-3.1.1.min.js"></script>
    <script type="text/javascript" src="Box2d.min.js"></script>
    <script type="text/javascript" src="Queue.js"></script>
	<script type="text/javascript" src="gcode.js"></script>
	<script type="text/javascript" src="engine.js"></script>
    <script type="text/javascript">

var gcodes = new Queue();
var movements = new Queue();

var world;
var ctx;
var drawingctx;

// box2d to canvas scale: 1 metre in box2d = 600px of canvas
var scale = 600;

// frame per sec for the world
var fps = 60;

// distance between the two motors
d = m(1)-cm(6);

// the smallest visible distance
resolution = mm(1);

// the actual drawing area in the world
var bbox = {x: cm(10), y: cm(10), width: cm(80)-suspensionMargin, height: cm(80)-suspensionMargin};

var il1 = length1(0,0);
var il2 = length2(0,0);
var cl1 = il1;
var cl2 = il2;

x1 = cm(0);
y1 = cm(0);
x2 = cm(5);
y2 = cm(0);
x3 = cm(5);
y3 = cm(5);
x4 = cm(0);
y4 = cm(5);

line(0,0,x1,y1,false);
line(x1,y1,x2,y2,true);
line(x2,y2,x3,y3,true);
line(x3,y3,x4,y4,true);
line(x4,y4,x1,y1,true);

function length1(x,y)
{
    x += bbox.x-suspensionMargin;
    y += bbox.y-suspensionMargin;
    return Math.sqrt((x*x) + (y*y));
}

function length2(x,y)
{
    x += bbox.x-suspensionMargin;
    y += bbox.y-suspensionMargin;
    return Math.sqrt(((d-x)*(d-x)) + (y*y));
}

function line(x1,y1,x2,y2,draw)
{
    if(x1==x2 && y1==y2) return;

    var l = Math.sqrt(((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)));
    var ns = Math.ceil(l / resolution);
  
    if(x1 == x2)
    {
        var dy = (y2 - y1) / ns;
        var x = x1;
        var y = y1;
     
        for(var i=0; i<ns; i++)
        {
            y += dy;
            
            var l1 = length1(x,y);
            var l2 = length2(x,y);
            
            movements.enqueue({l1: l1-cl1, l2: l2-cl2, draw: draw});
            
            cl1 = l1;
            cl2 = l2;
        }     
    }
    else
    {
        var m = (y2 - y1) / (x2 - x1);
        var b = - x1 * m + y1;
          
        var dx = (x2 - x1) / ns;

        var x = x1;
        
        for(var i=0; i<ns; i++)
        {
            x += dx;
            
            var y = m * x + b;
            var l1 = length1(x,y);
            var l2 = length2(x,y);
            
            movements.enqueue({l1: l1-cl1, l2: l2-cl2, draw: draw});
            
            cl1 = l1;
            cl2 = l2;
        }
    }
}
      
function step() 
{
    var timeStep = 1.0/(fps * 0.8);
     
    var m; 
    var sposx = nozzle.GetPosition().x;
    var sposy = nozzle.GetPosition().y;
	
    if(!movements.isEmpty())
    {
        m = movements.dequeue();
        distance_joint1.SetLength(distance_joint1.GetLength() + m.l1);
        distance_joint2.SetLength(distance_joint2.GetLength() + m.l2);
    }	 
	 
    //move the box2d world ahead
    world.Step(timeStep , 8 , 3);
    world.ClearForces();
     
    //redraw the world
	world.DrawDebugData();
        
    if(m && m.draw)
    {
        var pos = nozzle.GetPosition();
		
        drawingctx.beginPath();
		drawingctx.moveTo(sposx, sposy);
        drawingctx.lineTo(pos.x, pos.y);
		drawingctx.strokeStyle = "black"; 
        drawingctx.stroke(); 
    }
        
    //call this function again after 1/60 seconds or 16.7ms
    setTimeout(step , 1000 / fps);
}  
  
// main entry point
$(function() 
{
    //first create the world
    world = createWorld(scale);
     
    var canvas = $('#canvas');
    ctx = canvas.get(0).getContext('2d');

    var drawingcanvas = $('#drawinglayer');
    drawingctx = drawingcanvas.get(0).getContext('2d');
    drawingctx.scale(scale,scale);
	drawingctx.lineWidth=mm(1);
	
	drawingctx.beginPath();
	drawingctx.rect(bbox.x, bbox.y, bbox.width, bbox.height);
	drawingctx.strokeStyle = "black";
	drawingctx.stroke();  	
	          
    //start stepping
    step();
});
   
   </script>
   
   
</html>