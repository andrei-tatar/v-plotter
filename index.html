<html>
   <head>
      <title>Hanging plotter simulator</title>
   </head>
   <body>
        <div style="position: relative;">
         <canvas id="canvas" width="650" height="600" 
           style="position: absolute; left: 0; top: 0; z-index: 0;"></canvas>
         <canvas id="drawinglayer" width="650" height="600" 
           style="position: absolute; left: 0; top: 0; z-index: 1;"></canvas>
        </div>   
   </body>
   <script type="text/javascript" src="jquery-3.1.1.min.js"></script>
   <script type="text/javascript" src="Box2d.min.js"></script>
   <script type="text/javascript" src="Queue.js"></script>
   <script type="text/javascript">

      
var gcodes = new Queue();
var movements = new Queue();

//box2d to canvas scale , therefor 1 metre of box2d = 600px of canvas :)
var scale = 600;

// Distance between the two motors
d = m(1)-cm(6);
resolution = mm(1);

var suspensionMargin = cm(3);
var bbox = {x: cm(10), y: cm(10), width: cm(80)-suspensionMargin, height: cm(80)-suspensionMargin};

var il1 = length1(0,0);
var il2 = length2(0,0);
var cl1 = il1;
var cl2 = il2;

x1 = cm(0);
y1 = cm(0);
x2 = cm(5);
y2 = cm(0);
x3 = cm(5);
y3 = cm(5);
x4 = cm(0);
y4 = cm(5);

line(0,0,x1,y1,false);
line(x1,y1,x2,y2,true);
line(x2,y2,x3,y3,true);
line(x3,y3,x4,y4,true);
line(x4,y4,x1,y1,true);

function length1(x,y)
{
    x += bbox.x-suspensionMargin;
    y += bbox.y-suspensionMargin;
    return Math.sqrt((x*x) + (y*y));
}

function length2(x,y)
{
    x += bbox.x-suspensionMargin;
    y += bbox.y-suspensionMargin;
    return Math.sqrt(((d-x)*(d-x)) + (y*y));
}

function mm(d)
{
	return d/1000;
}

function cm(d)
{
	return d/100;
}

function m(d)
{
	return d;
}

function line(x1,y1,x2,y2,draw)
{
    if(x1==x2 && y1==y2) return;

    var l = Math.sqrt(((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)));
    var ns = Math.ceil(l / resolution);
  
    if(x1 == x2)
    {
        var dy = (y2 - y1) / ns;
        var x = x1;
        var y = y1;
     
        for(var i=0; i<ns; i++)
        {
            y += dy;
            
            var l1 = length1(x,y);
            var l2 = length2(x,y);
            
            movements.enqueue({l1: l1-cl1, l2: l2-cl2, draw: draw});
            
            cl1 = l1;
            cl2 = l2;
        }     
    }
    else
    {
        var m = (y2 - y1) / (x2 - x1);
        var b = - x1 * m + y1;
          
        var dx = (x2 - x1) / ns;

        var x = x1;
        
        for(var i=0; i<ns; i++)
        {
            x += dx;
            
            var y = m * x + b;
            var l1 = length1(x,y);
            var l2 = length2(x,y);
            
            movements.enqueue({l1: l1-cl1, l2: l2-cl2, draw: draw});
            
            cl1 = l1;
            cl2 = l2;
        }
    }
}
   
var b2Vec2 = Box2D.Common.Math.b2Vec2
    , b2AABB = Box2D.Collision.b2AABB
    , b2BodyDef = Box2D.Dynamics.b2BodyDef
    , b2Body = Box2D.Dynamics.b2Body
    , b2FixtureDef = Box2D.Dynamics.b2FixtureDef
    , b2Fixture = Box2D.Dynamics.b2Fixture
    , b2World = Box2D.Dynamics.b2World
    , b2MassData = Box2D.Collision.Shapes.b2MassData
    , b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape
    , b2CircleShape = Box2D.Collision.Shapes.b2CircleShape
    , b2DebugDraw = Box2D.Dynamics.b2DebugDraw
    , b2MouseJointDef =  Box2D.Dynamics.Joints.b2MouseJointDef
    , b2DistanceJointDef =  Box2D.Dynamics.Joints.b2DistanceJointDef
    , b2Shape = Box2D.Collision.Shapes.b2Shape
    , b2Joint = Box2D.Dynamics.Joints.b2Joint
    , b2Settings = Box2D.Common.b2Settings
    ;
 
var world;
var ctx;
var drawingctx;
var canvas_width;
var canvas_height;
  
var distance_joint1;
var distance_joint2;
var nozzle;
 
//Draw a world - this method is called in a loop to redraw the world
function draw_world(world, context) 
{
    world.DrawDebugData();
}
 
//Create box2d world object
function createWorld() 
{
    //Gravity vector x, y - 10 m/s2 - thats earth!!
    var gravity = new b2Vec2(0, 10);
     
    world = new b2World(gravity , false);
     
    //setup debug draw
    var debugDraw = new b2DebugDraw();
    debugDraw.SetSprite(document.getElementById("canvas").getContext("2d"));
    debugDraw.SetDrawScale(scale);
    debugDraw.SetFillAlpha(0.5);
    debugDraw.SetLineThickness(1.0);
    debugDraw.SetFlags(b2DebugDraw.e_shapeBit | b2DebugDraw.e_jointBit);
     
    world.SetDebugDraw(debugDraw);
     
    //create some objects
    ground = createBox(world, m(0.5), m(1), m(1), cm(3), {type : b2Body.b2_staticBody});
    var a = createBox(world, suspensionMargin, suspensionMargin, cm(3) , cm(3), {type : b2Body.b2_staticBody});
    var b = createBox(world, m(1)-suspensionMargin, suspensionMargin, cm(3), cm(3), {type : b2Body.b2_staticBody});
    nozzle = createBall(world, bbox.x, bbox.y, cm(3/2));
     
    //create distance joint between b and c
    distance_joint1 = new b2DistanceJointDef();
    distance_joint1.bodyA = a;
    distance_joint1.bodyB = nozzle;
    //connect the centers - center in local coordinate - relative to body is 0,0
    distance_joint1.localAnchorA = new b2Vec2(0, 0);
    distance_joint1.localAnchorB = new b2Vec2(0, 0);
    //length of joint
    distance_joint1.length = il1;
    distance_joint1.collideConnected = true;

    //create distance joint between b and c
    distance_joint2 = new b2DistanceJointDef();
    distance_joint2.bodyA = b;
    distance_joint2.bodyB = nozzle;
    //connect the centers - center in local coordinate - relative to body is 0,0
    distance_joint2.localAnchorA = new b2Vec2(0, 0);
    distance_joint2.localAnchorB = new b2Vec2(0, 0);
    //length of joint
    distance_joint2.length = il2;
    distance_joint2.collideConnected = true;
    
    //add the joint to the world
    distance_joint1 = world.CreateJoint(distance_joint1);
    distance_joint2 = world.CreateJoint(distance_joint2);
     
    return world;
}       
 
//Function to create a round ball, sphere like object
function createBall(world, x, y, radius, options) 
{
     //default setting
    options = $.extend(true, {
        'density' : 1.0 ,
        'friction' : 1.0 ,
        'restitution' : 0.5 ,
         
        'type' : b2Body.b2_dynamicBody
    }, options);
     
    var body_def = new b2BodyDef();
    var fix_def = new b2FixtureDef();
     
    fix_def.density = options.density || 1.0;
    fix_def.friction = 0.5;
    fix_def.restitution = 0.5;
     
    var shape = new b2CircleShape(radius);
    fix_def.shape = shape;
     
    body_def.position.Set(x , y);
     
    body_def.linearDamping = 0.0;
    body_def.angularDamping = 0.0;
     
    body_def.type = b2Body.b2_dynamicBody;
    body_def.userData = options.user_data;
     
    var b = world.CreateBody( body_def );
    b.CreateFixture(fix_def);
     
    return b;
}
 
//Create standard boxes of given height , width at x,y
function createBox(world, x, y, width, height, options) 
{
     //default setting
    options = $.extend(true, {
        'density' : 1.0 ,
        'friction' : 1.0 ,
        'restitution' : 0.5 ,
        'type' : b2Body.b2_dynamicBody
    }, options);
       
    var body_def = new b2BodyDef();
    var fix_def = new b2FixtureDef();
     
    fix_def.density = options.density;
    fix_def.friction = options.friction;
    fix_def.restitution = options.restitution;
     
    fix_def.shape = new b2PolygonShape();
         
    fix_def.shape.SetAsBox(width/2, height/2);
     
    body_def.position.Set(x , y);
     
    body_def.type = options.type;
    body_def.userData = options.user_data;
     
    var b = world.CreateBody( body_def );
    var f = b.CreateFixture(fix_def);
     
    return b;
}

function step() 
{
    var fps = 60;
    var timeStep = 1.0/(fps * 0.8);
     
    var m; 
    var sposx = nozzle.GetPosition().x;
    var sposy = nozzle.GetPosition().y;
	
    if(!movements.isEmpty())
    {
        m = movements.dequeue();
        distance_joint1.SetLength(distance_joint1.GetLength() + m.l1);
        distance_joint2.SetLength(distance_joint2.GetLength() + m.l2);
    }	 
	 
    //move the box2d world ahead
    world.Step(timeStep , 8 , 3);
    world.ClearForces();
     
    //redraw the world
    draw_world(world , ctx);
        
    if(m && m.draw)
    {
        var pos = nozzle.GetPosition();
		
        drawingctx.beginPath();
		drawingctx.moveTo(sposx, sposy);
        drawingctx.lineTo(pos.x, pos.y);
		drawingctx.strokeStyle = "black"; 
        drawingctx.stroke(); 
    }
        
    //call this function again after 1/60 seconds or 16.7ms
    setTimeout(step , 1000 / fps);
}
 
// main entry point
$(function() 
{
    //first create the world
    world = createWorld();
     
    var canvas = $('#canvas');
    ctx = canvas.get(0).getContext('2d');

    var drawingcanvas = $('#drawinglayer');
    drawingctx = drawingcanvas.get(0).getContext('2d');
    drawingctx.scale(scale,scale);
	drawingctx.lineWidth=mm(1);
	
	drawingctx.beginPath();
	drawingctx.rect(bbox.x, bbox.y, bbox.width, bbox.height);
	drawingctx.strokeStyle = "black";
	drawingctx.stroke();  	
	
    //get internal dimensions of the canvas
    canvas_width = parseInt(canvas.attr('width'));
    canvas_height = parseInt(canvas.attr('height'));
    canvas_height_m = canvas_height / scale;
          
    //start stepping
    step();
});
   
   </script>
   
   
</html>